<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Wait for asynchronous loads to complete | mysite </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Wait for asynchronous loads to complete | mysite ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/bossbobofather-cpu/noname/blob/main/Library/PackageCache/com.unity.addressables@38fa2290d5f2/Documentation~/AddressableAssetsAsyncOperationHandle.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="mysite">
            mysite
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="addressables-async-operation-handling">
<h1 id="wait-for-asynchronous-loads-to-complete">Wait for asynchronous loads to complete</h1>

<p>Addressables uses asynchronous operations for tasks that require loading or downloading data, which prevents these operations from blocking your application's execution while they complete.</p>
<p>In contrast to a <a href="SynchronousAddressables.html">synchronous operation</a>, which doesn't return control until the result is available, an asynchronous operation returns control to the calling method almost immediately. However, the results might not be available until some time in the future.</p>
<p>When you call a method, such as <a href="xref:UnityEngine.AddressableAssets.Addressables.LoadAssetAsync*"><code>LoadAssetAsync</code></a>, it doesn't return the loaded assets directly. Instead, it returns an <a href="xref:UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle"><code>AsyncOperationHandle</code></a> object, which you can use to access the loaded assets when they become available.</p>
<p>You can use the following techniques to wait for the results of an asynchronous operation while allowing other scripts to continue processing:</p>
<ul>
<li><a href="load-wait-asynchronous-coroutines.html">Coroutines and <code>IEnumerator</code> loops</a></li>
<li><a href="load-wait-asynchronous-events.html">Event based operation handling</a></li>
<li><a href="load-wait-asynchronous-async-await.html">Task based operation handling</a></li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>You can block the current thread to wait for the completion of an asynchronous operation. Doing so can introduce performance problems and frame rate hitches. Refer to <a href="SynchronousAddressables.html">Using operations synchronously</a> for more information.</p>
</div>
<h2 id="release-asyncoperationhandle-instances">Release AsyncOperationHandle instances</h2>
<p>Methods like <a href="xref:UnityEngine.AddressableAssets.Addressables.LoadAssetsAsync*"><code>LoadAssetsAsync</code></a> return <a href="xref:UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle"><code>AsyncOperationHandle</code></a> instances that give the results of the operation and a way to release both the results and the operation object itself.</p>
<p>You must keep the handle object for as long as you want to use the results. Depending on the situation, that might be one frame, until the end of a level, or even the lifetime of the application. Use the <a href="xref:UnityEngine.AddressableAssets.Addressables.Release*"><code>Addressables.Release</code></a> method to release operation handles and any associated Addressable assets.</p>
<p>Releasing an operation handle decrements the reference count of any assets loaded by the operation and invalidates the operation handle object itself. Refer to <a href="MemoryManagement.html">Memory management</a> for more information about reference counting in the Addressables system.</p>
<p>If you don't need to use the results of an operation beyond a limited scope, you can release the handles immediately. Some Addressables methods, such as <a href="xref:UnityEngine.AddressableAssets.Addressables.UnloadSceneAsync*"><code>UnloadSceneAsync</code></a> allow you to automatically release the operation handle when it's complete.</p>
<p>If an operation is unsuccessful, it's best practice to still release the operation handle. Unity releases any assets that it loaded during a failed operation, but releasing the handle still clears the handle's instance data. Some methods that load multiple assets, like <a href="xref:UnityEngine.AddressableAssets.Addressables.LoadAssetsAsync*"><code>LoadAssetsAsync</code></a>, give you the option to either keep any successfully loaded assets, or to fail and release everything if any part of the load operation fails.</p>
<h2 id="typed-and-typeless-operation-handles">Typed and typeless operation handles</h2>
<p>Most <code>Addressables</code> methods that start an operation return a generic <a href="xref:UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle%601"><code>AsyncOperationHandle&lt;T&gt;</code></a> struct, allowing type safety for the <a href="xref:UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle.Completed"><code>AsyncOperationHandle.Completed</code></a> event and for the <a href="xref:UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle.Result"><code>AsyncOperationHandle.Result</code></a> object. You can also use a non-generic <a href="xref:UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle"><code>AsyncOperationHandle</code></a> struct and convert between the two handle types as desired.</p>
<p>A runtime exception happens if you try to cast a non-generic handle to a generic handle of a wrong type. For example:</p>
<pre><code class="lang-cs" name="sample">
// Load asset using typed handle:
AsyncOperationHandle&lt;Texture2D&gt; textureHandle = Addressables.LoadAssetAsync&lt;Texture2D&gt;(&quot;mytexture&quot;);

// Convert the AsyncOperationHandle&lt;Texture2D&gt; to an AsyncOperationHandle:
AsyncOperationHandle nonGenericHandle = textureHandle;

// Convert the AsyncOperationHandle to an AsyncOperationHandle&lt;Texture2D&gt;:
AsyncOperationHandle&lt;Texture2D&gt; textureHandle2 = nonGenericHandle.Convert&lt;Texture2D&gt;();

// This will throw and exception because Texture2D is required:
AsyncOperationHandle&lt;Texture&gt; textureHandle3 = nonGenericHandle.Convert&lt;Texture&gt;();

</code></pre><h2 id="additional-resources">Additional resources</h2>
<ul>
<li><a href="load-wait-asynchronous-coroutines.html">Wait for asynchronous loads with coroutines</a></li>
<li><a href="load-wait-asynchronous-events.html">Wait for asynchronous loads with events</a></li>
<li><a href="load-wait-asynchronous-async-await.html">Wait for asynchronous loads with async and await</a></li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/bossbobofather-cpu/noname/blob/main/Library/PackageCache/com.unity.addressables@38fa2290d5f2/Documentation~/AddressableAssetsAsyncOperationHandle.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
