<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Subgraph Nodes | mysite </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Subgraph Nodes | mysite ">
      
      
      <link rel="icon" href="../../../../favicon.ico">
      <link rel="stylesheet" href="../../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../../public/main.css">
      <meta name="docfx:navrel" content="../../../../toc.html">
      <meta name="docfx:tocrel" content="../../../../toc.html">
      
      <meta name="docfx:rel" content="../../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/bossbobofather-cpu/noname/blob/main/Library/PackageCache/com.unity.shadergraph@287dd3fa176c/Documentation~/Shader-Graph-Sample-UGUI-Shaders-Subgraph-nodes.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../../index.html">
            <img id="logo" class="svg" src="../../../../logo.svg" alt="mysite">
            mysite
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="subgraph-nodes">Subgraph Nodes</h1>

<p>The subgraphs have been created to help speed up the process of creating user interface elements. They’re building blocks that can be strung together quickly to achieve various appearances and functionalities. You can see all of the subgraph nodes in the collection by opening this shader file:
Assets/Samples/Shader Graph/<your version>/UGUI Shaders/Subgraphs/SubgraphLibrary</your></p>
<p>The subgraphs are broken into the following categories:</p>
<ul>
<li><strong>Inputs</strong> - These subgraphs provide input data.</li>
<li><strong>Utilities</strong> - These subgraphs feature simple utilities to help with input data.</li>
<li><strong>Gradients</strong> - These nodes generate gradients in various shapes including linear, spherical, square, and custom.</li>
<li><strong>Helpers</strong> - these subgraphs provide commonly-used operations for building UI elements</li>
<li><strong>Patterns</strong> - These nodes generate procedural patterns that can be used as backgrounds or masks.  The patterns include clouds, bars, checkers, circle segments, hexagon tiles, player icon, rings, ring segments, square tiles, wedges, and window blinds.</li>
<li><strong>SDFs</strong> - Signed Distance Field shapes are the basis for UI elements. The value of each pixel in an SDF represents the distance to the edge of the shape. You can use the SDF data to create resolution-independent shapes that are either sharp or blurry. Shapes in the set include circle, hexagon, pill, rectangle, star, and triangle. This collection also contains operators for combining SDF shapes.</li>
<li><strong>Time</strong> - These nodes output time in various forms - looping, mirroredm, sine wave, etc.</li>
<li><strong>UV</strong> - These nodes manipulate UV coordinates including move, scale, tilt, mirror, invert, and more. Shapes and elements can be transformed by adjusting their UV coordinates with these nodes.
<img src="images/UITools-subgraphs.png" alt="A collection of graphical nodes within a node-based visual editor, grouped into labeled sections—Gradients, Helpers, Patterns, SDFs, Time, and UV. Each node features preview images and labeled inputs/outputs, handling elements like color, shape, noise, and UV manipulation."></li>
</ul>
<h2 id="inputs">Inputs</h2>
<h3 id="canvas-color">Canvas Color</h3>
<p>This subgraph outputs the UI element color in linear space, performing color space conversion on vertex color if the Canvas is set to store vertex colors in gamma space.
Make sure to check &quot;Disable Color Tint&quot; in the Graph Settings when using the Canvas Color node, to not tint the final output.</p>
<h2 id="utilities">Utilities</h2>
<h3 id="selectablestatecompare">SelectableStateCompare</h3>
<p>This subgraph takes a Selectable State as a float and outputs Boolean values to inform on the states.</p>
<h3 id="selectablestatepreview">SelectableStatePreview</h3>
<p>This subgraph takes a Selectable State as a float input and features a dropdown to override its value withing Shader Graph only. This allows previewing what things look like when in a given state.
This has no effect on the final shader that will always use the provided input.</p>
<h3 id="sliderdirectioncompare">SliderDirectionCompare</h3>
<p>This subgraph takes a Direction as a Vector2 and outputs Boolean values to inform on cardinals.</p>
<h3 id="sliderdirectionpreview">SliderDirectionPreview</h3>
<p>This subgraph takes a Direction as a Vector2 input and features a dropdown to override its value withing Shader Graph only. This allows previewing what things look like with a different direction is used.
This has no effect on the final shader that will always use the provided input.</p>
<h3 id="gradients">Gradients</h3>
<p>This node is a collection of commonly used gradients. You can select the gradient you want to use from the Style dropdown. By default, a horizontal LinearGradient is used as the input, but you can pass in any input gradient you want.</p>
<h4 id="cone-gradient">Cone Gradient</h4>
<p>Creates a Gradient, Normals, Height, and a Mask for a procedurally-generated cone. This allows you to create 3d effects in a 2d environment. The Size input port controls the size of the generated cone relative to the UV space. ConeHeight input controls the height above the base of the cone’s center point.  The LightDirection input port is a vector that determines the direction the light is coming from for the Diffuse gradient output. The Diffuse output uses the cone’s normals and the incoming LightDirection to calculate diffuse lighting. Areas of the Diffuse gradient facing away from the LightDirection will have negative values, so you may need to use a Saturate node to limit the range of the output to zero to one. The NormalTS output is a normalized vector that indicates the direction each pixel on the cone’s surface is facing. The Height output is a heightmap for the cone. The Mask output is white inside the cone and black outside.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/80sSunset</li>
<li>Examples/Indicators/FantasyMeter</li>
</ul>
<h4 id="linear-gradient">Linear Gradient</h4>
<p>This node uses UV coordinates to create a vertical or horizontal gradient from black to white. By default, the node uses the UV coordinates from the UI element, but you can also pass in your own coordinates to the UV input port. The U output port creates a horizontal gradient and the V output port creates a vertical gradient.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/80sSunset</li>
<li>Examples/ProgressBars/GradientBar</li>
</ul>
<h4 id="cube-gradient">Cube Gradient</h4>
<p>Creates a gradient, normals, height, and a mask for a procedurally-generated cube. This allows you to create 3d effects in a 2d environment. The InnerSize and OuterSize input ports control the size of the generated cube relative to the UV space. The LightDirection input port is a vector that determines the direction the light is coming from for the Diffuse gradient output. The Diffuse output uses the cube’s normals and the incoming LightDirection to calculate diffuse lighting. Areas of the Diffuse gradient facing away from the LightDirection will have negative values, so you may need to use a Saturate node to limit the range of the output to zero to one. The NormalTS output is a normalized vector that indicates the direction each pixel on the sphere’s surface is facing. The Mask output is white inside the sphere and black outside.</p>
<h4 id="sphere-gradient">Sphere Gradient</h4>
<p>Creates a gradient, normals, height, and a mask for a procedurally-generated sphere. This allows you to create 3d effects in a 2d environment. The Size input port controls the size of the generated sphere relative to the UV space. The LightDirection input port is a vector that determines the direction the light is coming from for the Diffuse gradient output. The Diffuse output uses the sphere’s normals and the incoming LightDirection to calculate diffuse lighting. Areas of the Diffuse gradient facing away from the LightDirection will have negative values, so you may need to use a Saturate node to limit the range of the output to zero to one. The NormalTS output is a normalized vector that indicates the direction each pixel on the sphere’s surface is facing. The Mask output is white inside the sphere and black outside.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Indicators/FantasyMeter</li>
</ul>
<h3 id="helpers">Helpers</h3>
<h4 id="anti-aliasing">Anti Aliasing</h4>
<p>You can use this node to create a perfectly anti-aliased edge from any SDF shape or gradient regardless of the size of the shape or the camera’s distance from the UI element. You can use it to create resolution-independent UI elements. The Cutoff input controls the point along the input gradient where the hard edge should be. See the documentation section entitled “How to create a resolution-independent shape” for instructions on using this node.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Indicators/FantasyMeter</li>
<li>Examples/Backgrounds/LavaLamp</li>
</ul>
<h4 id="aspect-ratio">Aspect Ratio</h4>
<p>Given the Width and Height of the UI element, this node calculates the aspect ratio of the UI element. It can be used to create buttons and widgets that correctly adapt to changes in the width or height of the assigned UI element. It works best when the WidthHeight input port is connected to the Width and Height parameters of the assigned UI element. See the documentation section entitled “How to make shapes that adapt to the aspect ratio of the UI element” for more information.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Indicators/AquaMeter</li>
<li>Subgraphs/SDFs/Pill</li>
</ul>
<h4 id="ease-curves">Ease Curves</h4>
<p>This node adjusts the falloff curve of the input gradient. There are 9 available falloff curves.  More information on the falloff curves can be found here: <a href="https://easings.net/">https://easings.net/</a>  By default, the input Gradient is LinearTimeMirror, but you can use any type of gradient you want.</p>
<h4 id="hash11">Hash11</h4>
<p>Given an input value In and a Seed, this node generates a deterministic random value in the 0 to 1 range as output. Time is used as the default input, but you can use any input value you want.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Indicators/FantasyMeter</li>
</ul>
<h4 id="hash21">Hash21</h4>
<p>Given a vector2 value UV (such as UV coordinates) and a Seed, this node generates a deterministic random value as output. UV0 is the default UV input, but you can use any vector 2 value you want.</p>
<h4 id="histogram-scan">Histogram Scan</h4>
<p>This node allows you to convert a gradient or SDF into a solid shape. You can control the Position along the gradient where the solid edge forms as well as the hardness of the edge using Contrast input. The lower the Contrast value, the softer the edge.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/ProgressBars/ProgressCircle</li>
<li>Examples/Indicators/DialMeter</li>
</ul>
<h4 id="lerp-multiple">Lerp Multiple</h4>
<p>This node works in a similar way as the Lerp node, but allows you to blend between 3 or 4 values instead of just 2. FracTime is used as the default for the T value but you can use any value you want.</p>
<h4 id="mirror">Mirror</h4>
<p>This node flips the input value back and forth. The number of times to repeat the back and forth pattern is determined by the Subdivisions input.</p>
<p>Usage Examples:</p>
<ul>
<li>Subgraphs/SDFs/Wave</li>
</ul>
<h4 id="posterizegradient">PosterizeGradient</h4>
<p>This node quantizes gradients into discrete steps. The number of steps is controlled by the Steps input. The step divisions can be divided to preserve the overall range or to preserve the step distance.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/ProgressBars/ProgressCircle</li>
<li>Examples/Indicators/SciFiMeter</li>
</ul>
<h4 id="random">Random</h4>
<p>Given UV coordinates and a Seed, this node generates random values - either Vector 2 or Float. Because the method used to generate the values uses a sine function, it is non-deterministic, may vary on various hardware platforms (depending on the hardware implementation of sine), and may exhibit repetitive patterns when given large input values. If you are seeing these issues, use the Hash11 or Hash21 nodes instead.</p>
<p>Usage Examples:</p>
<ul>
<li>Subgraphs/UV/Shake.shadersubgraph</li>
</ul>
<h4 id="roundedcorners">RoundedCorners</h4>
<p>This is a helper node used by the SDF Rectangle node.  It helps to generate the rounded corners of the rectangle.</p>
<p>Usage Examples:</p>
<ul>
<li>Subgraphs/SDFs/Rectangle</li>
</ul>
<h4 id="scene-color-blurred">Scene Color Blurred</h4>
<p>This node samples the Scene Color node in a spiral pattern and averages the result to create the appearance of blurring the scene background behind the UI element. Cycles is the number of turns of the spiral. Use Samples Per Cycle to control the number of samples in each cycle. The total number of samples is Cycles times Samples Per Cycle.  Higher numbers of samples result in smoother blur appearance but higher cost. Lower sample numbers give better performance but grainier results. See the Sticky Notes inside the subgraph for more information.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/BlurredHexagon</li>
</ul>
<h3 id="patterns">Patterns</h3>
<h4 id="animated-clouds">Animated Clouds</h4>
<p>Generates an animated cloud pattern. By default, the clouds are generated in screen space, but you can also pass in your own UV coordinates. You can control the color of the clouds with the Color1 and Color2 inputs.  The speed of cloud movement is controlled with the Speed input. And the size of the clouds can be controlled with the Scale input.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/TechGrid</li>
<li>Examples/Buttons/SciFiButton2</li>
</ul>
<h4 id="animated-sheen">Animated Sheen</h4>
<p>This node creates a scrolling highlight gradient. It’s intended to create the animated sheen on buttons - especially when the button is selected or the user’s mouse is hovering over the button. You can control the size of the effect with the Scale input. The angle of tilt can be adjusted with the Tilt input value. And you can control the Speed that the effect scrolls with the Speed input.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Buttons/AquaButton</li>
<li>Examples/Buttons/SciFiButton2</li>
</ul>
<h4 id="bars">Bars</h4>
<p>This node generates vertical or horizontal bars (an alternating black and white pattern) depending on the output port you use. You can control the number of bars using the Bars input.</p>
<h4 id="checkers">Checkers</h4>
<p>This node generates a simple checkerboard pattern. You can control the scale of the pattern using the Tiles input.</p>
<h4 id="circle-segments">Circle Segments</h4>
<p>This node divides a circle into the given number of segments and alternates them between black and white.  The width and blur of the segments can be controlled with the Spacing and Blur inputs. The segments can be output as triangles or lines. You can also rotate the pattern using the Rotation input.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Buttons/SciFiButton</li>
</ul>
<h4 id="hexagon-tiles">Hexagon Tiles</h4>
<p>This node creates a hexagon grid. The Tiles input controls the scale of the hexagon tiles. The Thickness input controls the width of the Stroke outlines. The Distance input controls the size of the white parts of the tiles relative to the black lines. The Blur input controls the blurriness of the tile outlines.  An interesting and useful inverse SDF effect can be achieved by setting the Distance input to 0 and the Blur input to 0.5.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/BlurredHexagon</li>
</ul>
<h4 id="player-icon">Player Icon</h4>
<p>This node creates an avatar icon. It combines the Circle and Pill SDF nodes. It’s a good example of how SDFs can be combined to create other shapes.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Buttons/SciFiButton</li>
<li>Examples/Indicators/DialMeter</li>
</ul>
<h4 id="rings">Rings</h4>
<p>This subgraph generates a series of concentric rings. You can select the number of rings with the Segments input. You can control how sharp or blurry the rings are with the Glow Min Max input. You can crop the rings at the edges with the Mask To Bounds input. The Offset input moves the rings toward or away from the center. By default it’s set to LinearTime but you can use any input value.</p>
<h4 id="ring-segments">Ring Segments</h4>
<p>This node generates a set of rotating ring segments. You can control the number of segments with the Segments input. The Size input controls how far the segments are from the center. The Blur input controls how sharp or blurry the edges of the segments are. The Thickness input controls the width of the segments. The Contrast input controls the falloff of the segment’s tail. The Rotation input controls the movement or position around the circle of the segments.</p>
<h4 id="square-tiles">Square Tiles</h4>
<p>This node generates a grid pattern of square tiles. The Tiles input controls the number of tiles in each dimension. Size controls the size of the white squares vs black lines in both dimensions. The lower these values are, the thicker the black outlines will be. Blur controls the sharpness/blurriness of the white squares. You’ll most likely need to turn the Size value down in order to make room for blurry edges.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/TechGrid</li>
<li>Examples/Buttons/SciFiButton2</li>
</ul>
<h4 id="wedges">Wedges</h4>
<p>This node generates wedge patterns of various types. The type can be selected with the dropdown box.</p>
<p>Usage Examples:</p>
<ul>
<li>Subgraphs/Gradients/SquareGradient</li>
</ul>
<h4 id="window-blinds">Window Blinds</h4>
<p>This node generates a bar pattern that can expand or contract to give the appearance of opening and closing window blinds. The Rotation input controls the orientation of the blinds in degrees. The Segments input controls the number of blinds. The Progress input controls the balance between black and white. Higher values make the white bars larger and lower values make the black bars larger. Blur controls the sharpness/blurriness of the bard edges.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Indicators/SciFiMeter</li>
</ul>
<h3 id="sdfs">SDFs</h3>
<p>SDFs or Signed Distance Fields are a very useful way of representing procedurally-generated shapes. The value of each pixel in the SDF represents the distance to the nearest shape edges. Pixels inside the shape have negative values - also indicating the distance to the nearest edge.</p>
<p>SDFs can be used to create a final shape using the Fill output of the SDF node, using the Histogram Scan node, or the AntiAliasing node.  The AntiAliasing node specifically will create shapes that are perfectly anti-aliased regardless of scale, camera distance, or resolution.</p>
<p>Each of the SDF shape nodes outputs the shape from the Fill output.  The Stroke port outputs an outline of the shape. The Stroke Thickness input parameter controls the width of the Stroke outline. The nodes also output the SDF itself as well as the Stroke SDF.</p>
<p>You can control the sharpness or blurriness of the Fill shape by using the Edge Min and Edge Max controls. The closer together the values are, the sharper the edge of the shape will be. The farther apart the values are, the softer/blurrier the edges will be. A blurry SDF shape makes a great drop shadow.</p>
<h4 id="circle">Circle</h4>
<p>Creates a circle shape.</p>
<ul>
<li>Usage Examples:</li>
<li>Examples/Buttons/SciFiButton</li>
<li>Examples/Indicators/FantasyMeter</li>
<li>Examples/Indicators/DialMeter</li>
</ul>
<h4 id="hexagon">Hexagon</h4>
<p>Creates a hexagon shape. It’s possible to round the corners of the hexagon using the Corner Radius input parameter.</p>
<h4 id="pill">Pill</h4>
<p>Generates a pill shape. You can control the height of the pill with the Size parameter. You can control the width of the pill with the Width parameter. To control the aspect ratio of the pill, use the WidthHeight parameter to enter the dimensions of the UI element.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Buttons/AquaButton</li>
<li>Examples/ProgressBars/GradientBar</li>
</ul>
<h4 id="rectangle">Rectangle</h4>
<p>Creates a rectangle shape. You can round the corners of the rectangle using the four Corner Radii input values. To control the aspect ratio of the rectangle, use the WidthHeight parameter to enter the dimensions of the UI element.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Buttons/SimpleButton</li>
<li>Examples/Backgrounds/RoundedRectangleBubble</li>
</ul>
<h4 id="star">Star</h4>
<p>Creates a star shape. You can control the number of points and the point distance.</p>
<h4 id="triangle">Triangle</h4>
<p>Creates a triangle shape. It’s possible to round the corners of the triangle using the Corner Radius input parameter.</p>
<h4 id="waves">Waves</h4>
<p>Generates an animated wave pattern from any SDF. You can control the number of waves and the movement of the waves using the Repetitions and Movement parameters.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Indicators/FantasyMeter</li>
</ul>
<h4 id="sdf-intersect">SDF Intersect</h4>
<p>This is a basic boolean intersection operation between two SDFs. The result is the intersection where the two shapes overlap.  Using the Smooth output allows the result to have a soft blend instead of the hard edge.</p>
<h4 id="sdf-subtract">SDF Subtract</h4>
<p>This is a basic boolean intersection operation between two SDFs. The result is the second SDF subtracted from the first.  Using the Smooth output allows the result to have a soft blend instead of the hard edge.</p>
<h4 id="sdf-unite">SDF Unite</h4>
<p>This is a basic boolean intersection operation between two SDFs. The result is the two SDF shapes combined together.  Using the Smooth output allows the result to have a soft blend instead of the hard edge.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Backgrounds/LavaLamp</li>
</ul>
<h3 id="time">Time</h3>
<h4 id="lineartime">LinearTime</h4>
<p>Outputs time values that increase linearly. The Loop output increases linearly from 0 to 1 and then jumps back to zero.  The Mirror output increases linearly from 0 to 1 and then decreases linearly back to 0 and repeats this back and forth cycle. The Switch output jumps from 0 directly to 1 and then back to 0 again.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/80sSunset</li>
<li>Examples/Buttons/SciFiButton2</li>
<li>Examples/Indicators/FantasyMeter</li>
</ul>
<h4 id="sinetime">SineTime</h4>
<p>The Raw output flows in a smooth curve from -1 to 1 and back. The Normalized output flows in a smooth curve between 0 and 1.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/ProgressBars/FancyLoading</li>
<li>Examples/Backgrounds/LavaLamp</li>
</ul>
<h4 id="timeoffset">TimeOffset</h4>
<p>Allows you to use a mask to determine areas where time is offset. The maximum offset value is defined by the Offset input. Areas where the Mask is 1 are time offset by the maximum amount. Areas where the Mask is 0 are not time offset.</p>
<h3 id="uv">UV</h3>
<h4 id="gridtiles">GridTiles</h4>
<p>Divides the UV space into the number of tiles defined by Tile U and Tile V. Aspect ratio can be maintained by inputting correct values into WidthHeight</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Indicators/FantasyMeter</li>
<li>Examples/ProgressBars/FancyLoading</li>
</ul>
<h4 id="halftone">Halftone</h4>
<p>Divides the UV space into halftone space or outputs a halftone pattern based on the input gradient where the size of the dots are determined by the shades in the input gradient. Areas where the input gradient is white have the largest halftone dots.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Backgrounds/Halftone</li>
</ul>
<h4 id="invert">Invert</h4>
<p>Flips the U coordinate, the V coordinate, or both.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Indicators/DialMeter</li>
<li>Examples/ProgressBars/GradientBar</li>
<li>Examples/ProgressBars/ProgressCircle</li>
</ul>
<h4 id="mirroruv">MirrorUV</h4>
<p>Takes UV coordinates in the 0 to 1 range and converts them to go from 0 to 1 to 0 again. You can control the offset, rotation, scale, and axis to mirror.</p>
<h4 id="move">Move</h4>
<p>Moves UV coordinates the amount specified by the Move input.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/80sSunset</li>
<li>Examples/Backgrounds/LavaLamp</li>
<li>Examples/Backgrounds/WarpedGradient</li>
<li>Examples/Buttons/SimpleButton</li>
</ul>
<h4 id="perspective">Perspective</h4>
<p>Distorts UV coordinates to make it look like perspective is applied as if the object were rotated away from the camera. Because of the perspective warping, some empty space is created around the edges. This empty space is black in the Alpha output. The Alpha Threshold and Alpha Feather inputs control the edges of the empty space.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/ProgressBars/FancyLoading</li>
<li>Examples/Backgrounds/80sSunset</li>
</ul>
<h4 id="posterizeuv">PosterizeUV</h4>
<p>Divides smooth UV coordinates into discrete, quantized units. The number of units can be specified with the Steps input. This node works well to convert a high resolution image into a low resolution one.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Backgrounds/Pixelation</li>
</ul>
<h4 id="scale">Scale</h4>
<p>Scales texture coordinates by the amount specified in Scale around the point specified by Pivot Point.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Backgrounds/RoundedRectangleBubble</li>
<li>Examples/Buttons/SciFiButton</li>
<li>Examples/Indicators/DialMeter</li>
</ul>
<h4 id="shake">Shake</h4>
<p>Oscillates UV coordinates back and forth quickly by a random amount and using the Speed and Strength inputs.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Indicators/SciFiMeter</li>
</ul>
<h4 id="tilt">Tilt</h4>
<p>Tilts the UV coordinates so that the resulting object slants to the left or right.</p>
<p>Usage Examples:</p>
<ul>
<li>Examples/Indicators/SciFiMeter</li>
<li>Examples/ProgressBars/SimpleLoading</li>
</ul>
<h4 id="waves-1">Waves</h4>
<p>Distorts the UV coordinates in a wave pattern. The strength and size of the waves can be controlled with the Amplitude and Frequency inputs.</p>
<p>Usage Example:</p>
<ul>
<li>Examples/Indicators/FantasyMeter</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/bossbobofather-cpu/noname/blob/main/Library/PackageCache/com.unity.shadergraph@287dd3fa176c/Documentation~/Shader-Graph-Sample-UGUI-Shaders-Subgraph-nodes.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
